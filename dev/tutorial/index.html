<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using PowerModelsADA · PowerModelsADA.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerModelsADA.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quickguide/">Quick Start Guide</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><a class="tocitem" href="../specification/">Technical Specifications</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Distributed Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../admm/">ADMM</a></li><li><a class="tocitem" href="../atc/">ATC</a></li><li><a class="tocitem" href="../app/">APP</a></li><li><a class="tocitem" href="../aladin/">ALADIN</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Using PowerModelsADA</a><ul class="internal"><li><a class="tocitem" href="#Run-Distributed-Algorithm"><span>Run Distributed Algorithm</span></a></li></ul></li><li><a class="tocitem" href="../newalgorithm/">User-defined Algorithm</a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../comparison/">Comparison Results</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Using PowerModelsADA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using PowerModelsADA</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mkhraijah/PowerModelsADA.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p><code>PowerModelsADA</code> solves OPF problems using either a pre-defined distributed algorithm or a user-defined algorithm. This page shows examples of solving the OPF problem using the pre-defined algorithms and how to define a new alternating distributed algorithm.</p><p>The distributed algorithm-specific functions are stored in modules. Each module contains at least three main functions: initialization, building, and update functions. Each module contains a solve function that solves the OPF by passing the case, solver, and power flow model.</p><p>The distributed algorithm module and solve function are:</p><ul><li>ADMM: modules: <code>admm_methods</code> and <code>admm_coordinated_methods</code>. solve functions: <code>solve_dopf_admm</code> and <code>solve_dopf_admm_coordinated</code></li><li>ATC: modules: <code>atc_methods</code> and <code>atc_coordinated_methods</code>. solve functions: <code>solve_dopf_atc</code> and <code>solve_dopf_atc_coordinated</code></li><li>APP: modules: <code>app_methods</code>. solve functions: <code>solve_dopf_app</code></li><li>ALADIN: modules: <code>aladin_coordinated_methods</code>. solve function: <code>solve_dopf_aladin_coordinated</code></li><li>Adaptive ADMM: Modules: <code>adaptive_admm_methods</code> and <code>adaptive_admm_coordinated_methods</code>. solve functions: <code>solve_dopf_adaptive_admm</code> and <code>solve_dopf_adaptive_admm_coordinated</code></li></ul><h2 id="Run-Distributed-Algorithm"><a class="docs-heading-anchor" href="#Run-Distributed-Algorithm">Run Distributed Algorithm</a><a id="Run-Distributed-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Run-Distributed-Algorithm" title="Permalink"></a></h2><p>To solve the OPF problem, we need first to import the <code>PowerModelsADA</code> package and an optimization solver. In this case we use the NLP solver <code>Ipopt</code>. You can install the solver using <code>using Pkg, Pkg.add(&quot;Ipopt&quot;)</code>. Then run the following code while you are inside the PowerModelsADA package directory.</p><pre><code class="language-julia hljs">## Import package
using PowerModelsADA
using Ipopt </code></pre><p>Next, we need to upload a test case. We will use IEEE 14-bus system in <code>/test/data/</code> folder in MATPOWER format. The file can be loaded using <code>parse_file</code> from <code>PowerModels</code> package. The test system needs to be divided into multiple distinct areas. This can be checked by looking into <code>data[&quot;bus&quot;][bus_id][&quot;area&quot;]</code>.</p><pre><code class="language-julia hljs">## Read case with partition file and return dictionary of the partitioned case
case_path = &quot;test/data/case14.m&quot;
partition_file_path = &quot;test/data/case14_2areas.csv&quot;
data = parse_file(case_path)
assign_area!(data, partition_file_path)</code></pre><p>Now, the case study is loaded and ready to be used to solve the OPF problem using distributed algorithms. We first need to define parameters, load the solver, and select a power flow formulation <code>model_type</code> as follows:</p><pre><code class="language-julia hljs">
## Settings and optimizer initiation
max_iteration = 1000
tol = 1e-4
alpha = 1000
optimizer = optimizer_with_attributes(Ipopt.Optimizer, &quot;print_level&quot;=&gt;0)</code></pre><p>PowerModelsADA supports the following power flow models:</p><h3 id="Exact-power-flow"><a class="docs-heading-anchor" href="#Exact-power-flow">Exact power flow</a><a id="Exact-power-flow-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-power-flow" title="Permalink"></a></h3><pre><code class="language-julia hljs">model_type = ACPPowerModel # AC power flow model with polar bus voltage variables.
model_type = ACRPowerModel # AC power flow model with rectangular bus voltage variables.</code></pre><h3 id="Approximations"><a class="docs-heading-anchor" href="#Approximations">Approximations</a><a id="Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Approximations" title="Permalink"></a></h3><pre><code class="language-julia hljs">model_type = DCPPowerModel # Linearized &#39;DC&#39; power flow model.
model_type = LPACCPowerModel # LP AC power flow approximation.</code></pre><h3 id="Convex-relaxations"><a class="docs-heading-anchor" href="#Convex-relaxations">Convex relaxations</a><a id="Convex-relaxations-1"></a><a class="docs-heading-anchor-permalink" href="#Convex-relaxations" title="Permalink"></a></h3><pre><code class="language-julia hljs">model_type = SOCWRPowerModel # Second-order cone relaxation of bus injection model of AC power flow.
model_type = QCRMPowerModel # Quadratic-Convex relaxation of the AC power flow.
model_type = SDPWRMPowerModel # Semidefinite relaxation of AC power flow.
model_type = SparseSDPWRMPowerModel # Sparsity-exploiting semidefinite relaxation of AC power flow.</code></pre><p>To solve the OPF problem using ADMM algorithm using the solve function, we use the following :</p><pre><code class="language-julia hljs">data_area = solve_dopf_admm(data, model_type, optimizer, tol=tol, max_iteration=max_iteration, alpha=alpha)
</code></pre><p>To use multiprocessing features, we need to use the Distributed library, add processors, and upload the PowerModelsADA and the solver packages to the processors. For the best performance, the number of processors should be equal to the number of areas. The code becomes as follows:</p><pre><code class="language-julia hljs">using Distributed 
num_area = 4 # change the number to be equal to number of areas
addprocs(num_area, exeflags=&quot;--project&quot;)
@everywhere using PowerModelsADA
@everywhere using Ipopt
data_area = solve_dopf_admm(data, model_type, optimizer, tol=tol, max_iteration=max_iteration, alpha=alpha, multiprocessors=true)</code></pre><p>To compare the distributed algorithm objective function value with the central OPF, use <code>compare_solution</code> to get the absolute value of the relative error.</p><pre><code class="language-julia hljs">optimality_gap = compare_solution(data, data_area, model_type, optimizer)</code></pre><p>PowerModelsADA also provides the flexibility for more granular control of the distributed algorithm. We can use the following code to initialize the distributed algorithm (we use ADMM in this example).</p><pre><code class="language-julia hljs">
## define parameters and power flow model
max_iteration = 1000
tol = 1e-4
alpha = 1000
model_type = DCPPowerModel

## obtain areas idx
areas_id = get_areas_id(data)

## decompose the system into subsystems
data_area = decompose_system(data)

## initialize parameters using the algorithm-specific initialize function
for i in areas_id
    admm_methods.initialize_method(data_area[i], model_type; tol=tol, max_iteration=max_iteration, alpha = alpha)
end
</code></pre><p>We then start the iterative process of the distributed algorithm using while loop with a pre-define termination criteria as follows:</p><pre><code class="language-julia hljs">## initialize global counters
iteration = 0
flag_convergence = false

## start iteration
while iteration &lt; max_iteration &amp;&amp; flag_convergence == false

    ## solve local problem and update solution
    for i in areas_id
        result = solve_model(data_area[i], model_type, optimizer, admm_methods.build_method, solution_processors=admm_methods.post_processors)
        update_data!(data_area[i], result[&quot;solution&quot;])
    end

    ## share solution with neighbors
    for i in areas_id # sender subsystem
        for j in data_area[i][&quot;neighbors&quot;] # receiver subsystem
            shared_data = prepare_shared_data(data_area[i], j)
            receive_shared_data!(data_area[j], deepcopy(shared_data), i)
        end
    end

    # calculate mismatches and update convergence flags
    for i in areas_id
        dopf_method.update_method(data_area[i])
    end

    ## check global convergence and update iteration counters
    flag_convergence = update_global_flag_convergence(data_area)
    iteration += 1
end
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../aladin/">« ALADIN</a><a class="docs-footer-nextpage" href="../newalgorithm/">User-defined Algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 14 September 2023 22:51">Thursday 14 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

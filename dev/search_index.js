var documenterSearchIndex = {"docs":
[{"location":"aladin/#Augmented-Lagrangian-Alternating-Direction-Inexact-Newton-(ALADIN)","page":"ALADIN","title":"Augmented Lagrangian Alternating Direction Inexact Newton (ALADIN)","text":"","category":"section"},{"location":"aladin/#PowerModelsADA.solve_dopf_aladin_coordinated","page":"ALADIN","title":"PowerModelsADA.solve_dopf_aladin_coordinated","text":"solve_dopf_aladin_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level = true, p::Real=1000, mu::Real=1000, p_upper::Real=1e6, mu_upper::Real=2e6, r_p::Real=1.5, mu_p::Real=2, a1::Real=1, a2::Real=1, #     a3::Real=1, q_gamma::Real=0, sigma::Dict{String,Real}=Dict())\n\nSolve the distributed OPF problem using ALADIN algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \np::Real=1000 : parameter\nmu::Real=1000 : parameter\np_upper::Real=1e6 : parameter\nmu_upper::Real=2e6 : parameter\nr_p::Real=1.5 : parameter\nr_mu::Real=2 : parameter\na1::Real=1 : parameter\na2::Real=1 : parameter\na3::Real=1 : parameter\nq_gamma::Real=0 : parameter\nsigma::Dict{String, <:Any}=Dict() : dictionary with variable name as key and parameter value as values\n\n\n\n\n\n","category":"function"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.build_method_local","text":"build PowerModel object for the ALADIN algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.initialize_method_coordinator","text":"initialize the ALADIN algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.initialize_method_local","text":"initialize the ALADIN algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.objective_aladin_local-Tuple{AbstractPowerModel}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.objective_aladin_local","text":"ALADIN algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.solve_coordinator!-Tuple{Any, Any}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.solve_coordinator!","text":"solve the ALADIN algorithm coordinator problem\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.solve_method-Tuple{Union{String, Dict{String, var\"#s108\"} where var\"#s108\"}, DataType, Any}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.solve_method","text":"solve_method(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level = true, p::Real=1000, mu::Real=1000, p_upper::Real=1e6, mu_upper::Real=2e6, r_p::Real=1.5, mu_p::Real=2, a1::Real=1, a2::Real=1, #     a3::Real=1, q_gamma::Real=0, sigma::Dict{String,Real}=Dict())\n\nSolve the distributed OPF problem using ALADIN algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \np::Real=1000 : parameter\nmu::Real=1000 : parameter\np_upper::Real=1e6 : parameter\nmu_upper::Real=2e6 : parameter\nr_p::Real=1.5 : parameter\nr_mu::Real=2 : parameter\na1::Real=1 : parameter\na2::Real=1 : parameter\na3::Real=1 : parameter\nq_gamma::Real=0 : parameter\nsigma::Dict{String, <:Any}=Dict() : dictionary with variable name as key and parameter value as values\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.update_method_coordinator","text":"update the ALADIN algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"aladin/#PowerModelsADA.aladin_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s174\"} where var\"#s174\"}","page":"ALADIN","title":"PowerModelsADA.aladin_coordinated_methods.update_method_local","text":"update the ALADIN algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"comparison/#Comparison-Results","page":"Comparison Results","title":"Comparison Results","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"The results of using PowerModelsADAv0.1.1 on 9 test cases from PGLib-OPF is shown here. We benchmark three distributed algorithms with 5 power flow formulations.","category":"page"},{"location":"comparison/#Simulation-Setup","page":"Comparison Results","title":"Simulation Setup","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"We run the three distributed algorithms on a high-performance computing service with a 16-core CPU and 16GB of RAM. We produced the results shown here using Julia v1.8, and Ipopt solver.","category":"page"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"We report the results that achieved the l_2-norm of the mismatches less than 0.01 (radians and per unit) within 10,000 iterations and the absolute value of the relative error less than 1% of the central solution from PowerModels.jl.","category":"page"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"We tune the ADAs parameters by selecting large values and gradually reducing the values until reaching a good solution. For the ADMM and APP, we started with alpha = 10^6 and divided by 10 for the next run, while for the ATC we started with alpha =12 and subtracted 0.099 for the next run.","category":"page"},{"location":"comparison/#Polar-Form-ACOPF","page":"Comparison Results","title":"Polar Form ACOPF","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 1.13 14 1.70 28 5.36 31\n24_ieee_rts 4 21.02 97 7.82 67 37.84 207\n30_ieee 3 2.18 24 3.89 43 2.33 25\n30pwl 3 7.40 24 4.08 36 10.73 49\n39_epri 3 20.14 89 239.80 1261 179.63 873\n73_ieee_rts 3 14.37 61 18.61 58 23.02 83\n179_goc 3 31.42 66 62.06 81 76.82 166\n300_ieee 4 21.51 66 651.26 920 28.16 77\n588_sdet 8 295.05 871 3133.82 1971 437.17 1283","category":"page"},{"location":"comparison/#Rectangular-Form-ACOPF","page":"Comparison Results","title":"Rectangular Form ACOPF","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 1.04 14 1.75 28 2.80 33\n24_ieee_rts 4 11.45 95 8.19 66 23.70 206\n30_ieee 3 3.20 22 3.53 40 3.36 24\n30pwl 3 1.07 10 6.82 59 6.13 48\n39_epri 3 11.40 86 323.25 1243 12.12 95\n73_ieee_rts 3 10.38 60 21.85 58 19.76 116\n179_goc 3 47.25 122 63.58 83 64.74 170\n300_ieee 4 17.89 44 1088.83 900 33.34 94\n588_sdet 8 401.70 1031 3838.72 1977 473.00 1181","category":"page"},{"location":"comparison/#DC-Approximation","page":"Comparison Results","title":"DC Approximation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 1.24 15 0.79 45 1.24 21\n24_ieee_rts 4 12.02 174 2.61 60 14.05 199\n30_ieee 3 1.41 21 0.35 45 1.44 20\n30pwl 3 1.53 18 0.34 42 1.38 20\n39_epri 3 4.90 69 6.181 69 4.51 64\n73_ieee_rts 3 6.81 75 4.88 55 6.77 79\n179_goc 3 4.56 37 3.24 27 5.21 44\n300_ieee 4 3.60 26 11.31 58 6.03 36\n588_sdet 8 106.01 656 18.535 655 185.20 1156","category":"page"},{"location":"comparison/#SOCP-Relaxation","page":"Comparison Results","title":"SOCP Relaxation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 1.29 12 2.16 39 0.98 12\n24_ieee_rts 4 3.85 39 4.18 32 4.94 51\n30_ieee 3 1.32 12 3.96 33 1.46 13\n30pwl 3 1.30 11 4.53 29 1.42 13\n39_epri 3 5.34 41 8.53 47 16.12 119\n73_ieee_rts 3 0.51 3 8.03 23 0.45 3\n179_goc 3 7.56 16 20.87 23 3.54 8\n300_ieee 4 5.64 11 51.75 42 7.18 14\n588_sdet 8 87.89 131 145.32 53 85.91 130","category":"page"},{"location":"comparison/#QC-Relaxation","page":"Comparison Results","title":"QC Relaxation","text":"","category":"section"},{"location":"comparison/","page":"Comparison Results","title":"Comparison Results","text":"Algorithm  ADMM  ATC  APP \nCase name Area Time Itr. Time Itr. Time Itr.\n14_ieee 2 2.09 15 4.37 24 4.47 15\n24_ieee_rts 4 15.53 55 22.07 50 19.10 66\n30_ieee 3 11.05 32 12.66 33 9.89 30\n30pwl 3 1.73 9 11.25 29 2.68 14\n39_epri 3 31.80 85 82.02 104 36.31 101\n73_ieee_rts 3 2.59 7 1268.75 1009 2.81 7\n179_goc 3 49.63 24 118.34 24 77.16 39\n300_ieee 4 18.52 11 602.90 60 57.31 27\n588_sdet 8 321.28 177 500.23 56 316.85 177","category":"page"},{"location":"app/#Auxiliary-Problem-Principle-(APP)","page":"APP","title":"Auxiliary Problem Principle (APP)","text":"","category":"section"},{"location":"app/#PowerModelsADA.solve_dopf_app","page":"APP","title":"PowerModelsADA.solve_dopf_app","text":"solve_dopf_app(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\",tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, alpha::Real=1000, beta::Real, gamma::Real)\n\nSolve the distributed OPF problem using APP algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1000 : algorithm parameter\nbeta::Real=2alpha : algorithm parameter\ngamma::Real=alpha : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"app/#PowerModelsADA.app_methods","page":"APP","title":"PowerModelsADA.app_methods","text":"APP algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"app/#PowerModelsADA.app_methods.build_method-Tuple{AbstractPowerModel}","page":"APP","title":"PowerModelsADA.app_methods.build_method","text":"build PowerModel object for the APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.initialize_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", Type}","page":"APP","title":"PowerModelsADA.app_methods.initialize_method","text":"initialize the APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.objective_app-Tuple{AbstractPowerModel}","page":"APP","title":"PowerModelsADA.app_methods.objective_app","text":"APP algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.solve_method-Tuple{Any, DataType, Any}","page":"APP","title":"PowerModelsADA.app_methods.solve_method","text":"solve distributed OPF using APP algorithm\n\n\n\n\n\n","category":"method"},{"location":"app/#PowerModelsADA.app_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"APP","title":"PowerModelsADA.app_methods.update_method","text":"update the APP algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#PowerModelsADA.build_pmada_ref-Tuple{Dict{String, var\"#s4\"} where var\"#s4\"}","page":"Library","title":"PowerModelsADA.build_pmada_ref","text":"\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_dual_residual!-Tuple{Dict{String, var\"#s48\"} where var\"#s48\"}","page":"Library","title":"PowerModelsADA.calc_dual_residual!","text":"calc_dual_residual!(data::Dict{String, <:Any}; central::Bool=false)\n\ncalculate the dual redidual as seen by the area. Set central=true if the algorithm uses the optimality condition of a central coordinator.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_global_dual_residual-Tuple{Dict{Int64, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.calc_global_dual_residual","text":"calculate the global mismatch based on local mismatch\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_global_mismatch-Tuple{Dict{Int64, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.calc_global_mismatch","text":"calculate the global mismatch based on local mismatch\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_mismatch!-Tuple{Dict{String, var\"#s48\"} where var\"#s48\"}","page":"Library","title":"PowerModelsADA.calc_mismatch!","text":"calc_mismatch!(data::Dict{String, <:Any}; central::Bool=false)\n\ncalculate the mismatch and return the area data dictionary with the mismatch as seen by the area. Set central=true if the algorithm uses the optimality condition of a central coordinator.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.flag_convergance-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.flag_convergance","text":"check flag convergance using mismatch and dual residual\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.initialize_dopf!-Tuple{Dict{String, var\"#s53\"} where var\"#s53\", DataType}","page":"Library","title":"PowerModelsADA.initialize_dopf!","text":"initialize dopf parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.instantiate_pmada_model-Tuple{Dict{String, var\"#s4\"} where var\"#s4\", Type, Any}","page":"Library","title":"PowerModelsADA.instantiate_pmada_model","text":"\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.print_convergence-Tuple{Dict, Int64}","page":"Library","title":"PowerModelsADA.print_convergence","text":"print final solution status\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.print_iteration","page":"Library","title":"PowerModelsADA.print_iteration","text":"print iteration information\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.print_iteration_coordinator","page":"Library","title":"PowerModelsADA.print_iteration_coordinator","text":"print iteration information\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.save_solution!-Tuple{Dict{String, var\"#s55\"} where var\"#s55\"}","page":"Library","title":"PowerModelsADA.save_solution!","text":"save last solution in previous_solutions vector\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf-Tuple{Dict{String, var\"#s3\"} where var\"#s3\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf","text":"solve_dopf(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmultiprocessors::Bool=false : enable multiprocessors using available workers. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated-Tuple{Dict{String, var\"#s49\"} where var\"#s49\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated","text":"solve_dopf_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmultiprocessors::Bool=false : enable multiprocessors using available workers. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated_mp-Tuple{Dict{Int64, var\"#s6\"} where var\"#s6\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated_mp","text":"solve_dopf_coordinated_mp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator on multiprocessors. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_coordinated_sp-Tuple{Dict{Int64, var\"#s5\"} where var\"#s5\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_coordinated_sp","text":"solve_dopf_coordinated_sp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, multiprocessors::Bool=false, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using distributed algorithm with central coordinator on single-processors.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method_local::Function : initialize the local algorithm parameters and shared variables\ninitialize_method_coordinator::Function : initialize the coordinator algorithm parameters and shared variables\nupdate_method_local::Function : update the local data after each iteration\nupdate_method_coordinator::Function : update the coordinator data after each iteration\nbuild_method_local::Function : local problem formulation\nbuild_method_coordinator::Function : coordinator problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previous\\solution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_mp-Tuple{Dict{Int64, var\"#s5\"} where var\"#s5\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_mp","text":"solve_dopf_mp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm on multiprocessors. Multiprocessors feature requires loading the PowerModelsADA and the optimizer packages on all the processors using @everywhere using <package_name>.\n\nArguments:\n\ndata::Dict{Int64, <:Any} : dictionary contains area data in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_dopf_sp-Tuple{Dict{Int64, var\"#s50\"} where var\"#s50\", DataType, Any, Module}","page":"Library","title":"PowerModelsADA.solve_dopf_sp","text":"solve_dopf_sp(data::Dict{String, <:Any}, model_type::DataType, optimizer, dopf_method::Module; print_level::Int64=1, mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, save_data::Vector{String}=[], kwargs...)\n\nSolve OPF problem using fully distributed algorithm on single-processor.\n\nArguments:\n\ndata::Dict{Int64, <:Any} : dictionary contains area data in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\ndopf_method::Module : module contains the distributed algorithm methods as follows:\ninitialize_method::Function : initialize the algorithm parameters and shared variables\nupdate_method::Function : update the algorithm after each iteration\nbuild_method::Function : problem formulation\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nsavedata::Vector{String}=[] : vector contains the keys of the dictionaries to be saved at each iteration in \"previoussolution\". For example, savedata=[\"solution\", \"sharedvariable\", \"mismatch\"]\nkwargs = includes algorithm-specific and initialization parameters\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.solve_pmada_model-Tuple{Dict{String, var\"#s5\"} where var\"#s5\", Type, Any, Any}","page":"Library","title":"PowerModelsADA.solve_pmada_model","text":"\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_flag_convergence!-Tuple{Dict{String, var\"#s50\"} where var\"#s50\"}","page":"Library","title":"PowerModelsADA.update_flag_convergence!","text":"check the shared variables of a local area are within tol\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_global_flag_convergence-Tuple{Dict{Int64, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.update_global_flag_convergence","text":"check the flag convergence for all areas and return a global variables\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_iteration!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.update_iteration!","text":"update iteration\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_shared_variable!-Tuple{AbstractPowerModel, Dict{String, var\"#s53\"} where var\"#s53\"}","page":"Library","title":"PowerModelsADA.update_shared_variable!","text":"update primal variables after obtaining a solution at each iteraton\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.update_solution!-Tuple{AbstractPowerModel, Dict{String, var\"#s54\"} where var\"#s54\"}","page":"Library","title":"PowerModelsADA.update_solution!","text":"update the area data solution dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.add_virtual_gen-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", Vector{T} where T, Int64}","page":"Library","title":"PowerModelsADA.add_virtual_gen","text":"add virtual generators at the neighboring buses of an area\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.arrange_areas_id!-Tuple{Dict{String, var\"#s177\"} where var\"#s177\"}","page":"Library","title":"PowerModelsADA.arrange_areas_id!","text":"arrange area ID from 1 to number of areas. This step is necessary when having area number 0 and using central coordinator\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", Matrix{Int64}}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a matrix with [bus, area] columnsor rows\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", String}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a CVS file with buses and area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s107\"} where var\"#s107\", Vector{Pair{Int64, Int64}}}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a vector with (bus => area) pairs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.assign_area!-Tuple{Dict{String, var\"#s55\"} where var\"#s55\", Dict}","page":"Library","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a dictionary with (bus => area) integers pairs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_coordinator-Tuple{Dict{String, var\"#s171\"} where var\"#s171\"}","page":"Library","title":"PowerModelsADA.decompose_coordinator","text":"obtain system coordinator data\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_system-Tuple{Dict{String, var\"#s107\"} where var\"#s107\"}","page":"Library","title":"PowerModelsADA.decompose_system","text":"decompose_system(data::Dict{String, <:Any})\n\ndecompose a system into areas defined by bus area.\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.decompose_system-Tuple{Dict{String, var\"#s180\"} where var\"#s180\", Int64}","page":"Library","title":"PowerModelsADA.decompose_system","text":"obtain an area decomposition with area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_area_id-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_area_id","text":"helper function to get the area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_area_id-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_area_id","text":"helper function to get the area ID\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_bus-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_areas_bus","text":"helper functions to all areas buses in a dicrionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_bus-Tuple{Dict{String, var\"#s172\"} where var\"#s172\"}","page":"Library","title":"PowerModelsADA.get_areas_bus","text":"helper functions to all areas buses in a dicrionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{Dict{Int64, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_areas_id-Tuple{Dict{String, var\"#s177\"} where var\"#s177\"}","page":"Library","title":"PowerModelsADA.get_areas_id","text":"helper function to get all areas IDs\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_local_bus-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_local_bus","text":"helper functions to get the area's local buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_local_bus-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", Int64}","page":"Library","title":"PowerModelsADA.get_local_bus","text":"helper functions to get the area's local buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{AbstractPowerModel, Vector{T} where T}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", Vector{T} where T}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_neighbor_bus-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", Int64}","page":"Library","title":"PowerModelsADA.get_neighbor_bus","text":"helper functions to get the area's neighbor buses\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{AbstractPowerModel, Int64}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between defined area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_shared_component-Tuple{Dict{String, var\"#s54\"} where var\"#s54\", Int64}","page":"Library","title":"PowerModelsADA.get_shared_component","text":"get the shared buses and branches between an area and all other areas\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.prepare_shared_data-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", Int64}","page":"Library","title":"PowerModelsADA.prepare_shared_data","text":"prepare the shared data with or without serialization\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.receive_shared_data!-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", Dict{String, var\"#s176\"} where var\"#s176\", Int64}","page":"Library","title":"PowerModelsADA.receive_shared_data!","text":"store received data in the local data dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.receive_shared_data!-Tuple{Dict{String, var\"#s179\"} where var\"#s179\", Vector{T} where T, Int64}","page":"Library","title":"PowerModelsADA.receive_shared_data!","text":"deserialize and store the received data in the local data dictionary\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.constraint_opf-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.constraint_opf","text":"define OPF problem constraints\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.no_objective-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.no_objective","text":"no objective function case\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.objective_min_fuel_and_consensus!","page":"Library","title":"PowerModelsADA.objective_min_fuel_and_consensus!","text":"define objective function using PowerModels and algorithm-specific objective\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.variable_opf-Tuple{AbstractPowerModel}","page":"Library","title":"PowerModelsADA.variable_opf","text":"define OPF problem variable\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.calc_dist_gen_cost-Tuple{Dict{Int64, var\"#s178\"} where var\"#s178\"}","page":"Library","title":"PowerModelsADA.calc_dist_gen_cost","text":"calculate distributed solution operation cost\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.compare_solution-Tuple{Dict{String, var\"#s178\"} where var\"#s178\", Dict{Int64, var\"#s177\"} where var\"#s177\", DataType, Any}","page":"Library","title":"PowerModelsADA.compare_solution","text":"compare the distributed algorithm solution with PowerModels centralized solution\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.get_diameter-Tuple{Any}","page":"Library","title":"PowerModelsADA.get_diameter","text":"get the communication network diameter\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA._var-Tuple{AbstractPowerModel, String, String}","page":"Library","title":"PowerModelsADA._var","text":"return JuMP variable object from PowerModel object\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.initial_value","page":"Library","title":"PowerModelsADA.initial_value","text":"initial_value(variable::String, initialization_method::String=\"flat\", value::Float64=0.0)\n\nassign initial value based on initialization method\n\nArguments:\n\nvariable::String : variable names\ninitializationmethod::String=\"flat\" : (\"flat\", \"previoussolution\", \"constant\")\nvalue::Float64=0.0 : return value if initialization_method = \"constant\"\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.initialize_all_variable","page":"Library","title":"PowerModelsADA.initialize_all_variable","text":"initialize_all_variable(data::Dict{String, <:Any}, model_type::DataType, dics_name::String=\"solution\", initialization_method::String=\"flat\")\n\nreturn a dictionary contains all the problem variables. can be used to store the solutions.\n\nArguments:\n\ndata::Dict{String, <:Any} : area data\nmodel_type::DataType : power flow formulation (PowerModel type)\ndics_name::String=\"solution\" : location of existing dicrionary to be used to worm start the output\ninitialization_method::String=\"flat\" : \"flat\" or \"worm\" initialization\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.initialize_shared_variable","page":"Library","title":"PowerModelsADA.initialize_shared_variable","text":"initialize shared variable dictionary\n\n\n\n\n\n","category":"function"},{"location":"library/#PowerModelsADA.variable_names-Tuple{DataType}","page":"Library","title":"PowerModelsADA.variable_names","text":"identifyall the variables names\n\n\n\n\n\n","category":"method"},{"location":"library/#PowerModelsADA.variable_shared_names-Tuple{DataType}","page":"Library","title":"PowerModelsADA.variable_shared_names","text":"identifythe shared bus and branch variables names\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Start-Guide","page":"Quick Start Guide","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"To solve the OPF problem using the ADMM use the solve function solve_dopf_admm. The solve function stores the result in a data dictionary contains subsystems information.","category":"page"},{"location":"quickguide/","page":"Quick Start Guide","title":"Quick Start Guide","text":"using PowerModelsADA\nusing Ipopt\n\nmodel_type = ACPPowerModel\nresult = solve_dopf_admm(\"test/data/case_RTS.m\", model_type, Ipopt.Optimizer; print_level=1, alpha=1000)","category":"page"},{"location":"newalgorithm/#User-Defined-Algorithm","page":"User-defined Algorithm","title":"User-Defined Algorithm","text":"","category":"section"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"To define a new algorithm, we need to define a module for the new algorithm that contains the main solve function in addition to three algorithm-specific functions. The three algorithm-specific are: initialize, build, and update. You can follow the example in the template file.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The module of xx algorithm should be defined and exported as xx_methods as follows:","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"\"\"\ntemplate for xx distributed algorithm\n\"\"\"\nmodule xx_methods\nusing ..PowerModelsADA\n\n### functions ###\n\nend\n# export the algorithm methods module and call method\nexport xx_methods, solve_dopf_xx","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The solve function is the main method to use the xx algorithm. The function takes the data, power flow formulation (model_type), JuMP solver object, and algorithm's parameters as required. The solve function should use the pre-defined algorithm flow as follows:","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"solve distributed OPF using xx algorithm\"\nfunction solve_method(data, model_type::DataType, optimizer; \n    mismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \n    print_level::Int64=1, parameters...)\n\n    solve_dopf(data, model_type, optimizer, xx_methods; \n    mismatch_method=mismatch_method, tol=tol, max_iteration=max_iteration, \n    print_level=print_level, parameters...)\nend","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The first algorithm-specific function is the initialize function. The function takes the area data file and adds to it the required parameters, counters, and shared variables. There are multiple built-in functions in PowerModelsADA that can be used to define the shared and received variables, as well as the dual variables. Note that the initialization function should include the initialize_dopf! to define the counters and convergence flags. We use kwargs with the ... to combine the algorithm's parameters and pass them to the initialize_method.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"initialize the xx algorithm\"\nfunction initialize_method(data::Dict{String, <:Any}, model_type::Type; kwargs...)\n\n    # initiate primal and dual shared variables\n    data[\"shared_variable\"] = Dict(to_area=> variable_name=> variable_index=> value)\n    data[\"received_variable\"] = Dict(from_area=> variable_name=>variable_index=> value)\n\n    # distributed algorithm settings\n    initialize_dopf!(data, model_type; kwargs...)\n\n    # xx parameters\n    data[\"parameter\"] = Dict(\"alpha\"=> get(kwargs, :alpha, 1000))\n\nend","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The second function is the build function, which builds the PowerModels object of the subproblem. The subproblems typically have the same variables and constraints as the central OPF problem and differ in the objective functions. To build a subproblem with the same variables and constraints as the central OPF problem with a specific objective function, we need to define the objective function using the template shown below. The objective function definition takes the PowerModels object and returns a JuMP expression. You can use the internal helper function _var to obtain the JuMP model variables' object defined in the PowerModels object.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"build PowerModel using xx algorithm\"\nfunction build_method(pm::AbstractPowerModel)\n\n    # define variables\n    variable_opf(pm)\n\n    # define constraints\n    constraint_opf(pm)\n  \n    # define objective function\n    objective_min_fuel_and_consensus!(pm, objective_function)\nend\n\n\"set the xx algorithm objective\"\nfunction objective_function(pm::AbstractPowerModel)\n\n    # to get the JuMP object of the active power of generator 1 use:\n    pg1 = _var(pm, :pg, 1)\n\n    ###\n    objective = pg1\n    ###\n    return objective\nend","category":"page"},{"location":"newalgorithm/#PowerModelsADA._var","page":"User-defined Algorithm","title":"PowerModelsADA._var","text":"return JuMP variable object from PowerModel object\n\n\n\n\n\n","category":"function"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The last function is to update the area dictionary after communicating the shared variables results with other areas.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"\"update the xx algorithm before each iteration\"\nfunction update_method(data::Dict{String, <:Any})\n\n    ### update subproblem parameters for the next iteration\n    ###\n\n    ### you can use predefined function to calculate the mismatches, check convergence, save progress etc. \n\n    calc_mismatch!(data, central=true)\n    update_flag_convergence!(data)\n    save_solution!(data)\n    update_iteration!(data)\nend\n","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"The final step is defining the post-processing functions and global keys. The post-processing functions perform tasks to the PowerModels object after solving the subproblem. PowerModelsADA comes with two post-processing functions. The first function updates the solution dictionary, and the second function updates the shared variables dictionary. The global keys are the keys that are used in the data area dictionary (related to the xx algorithm) and should be explicitly given by extending the existing _pmada_global_keys set of strings.","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"post_processors = [update_solution!, update_shared_variable!]\n\npush!(_pmada_global_keys, \"shared_variable\", \"received_variable\", \"dual_variable\")","category":"page"},{"location":"newalgorithm/","page":"User-defined Algorithm","title":"User-defined Algorithm","text":"This is a general way to define a distributed algorithm that is fully distributed with the same main algorithm flow as the pre-defined algorithms. For other algorithm flows, the solve function needs to be defined fully instead of using the pre-define function solve_dopf.","category":"page"},{"location":"specification/#Technical-Specifications","page":"Technical Specifications","title":"Technical Specifications","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Power-Flow-Formulation","page":"Technical Specifications","title":"Power Flow Formulation","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Optimization-Solver","page":"Technical Specifications","title":"Optimization Solver","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"specification/#Distributed-Algorithm","page":"Technical Specifications","title":"Distributed Algorithm","text":"","category":"section"},{"location":"specification/","page":"Technical Specifications","title":"Technical Specifications","text":"TODO","category":"page"},{"location":"atc/#Analytical-Target-Cascading-(ATC)","page":"ATC","title":"Analytical Target Cascading (ATC)","text":"","category":"section"},{"location":"atc/#PowerModelsADA.solve_dopf_atc","page":"ATC","title":"PowerModelsADA.solve_dopf_atc","text":"solve_dopf_atc(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level = true, print_optimizer_info::Bool=false, alpha::Real=1000, beta::Real = 1)\n\nSolve the distributed OPF problem using ATC algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1.05 : algorithm parameter\nbeta::Real=1.0 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"atc/#PowerModelsADA.solve_dopf_atc_coordinated","page":"ATC","title":"PowerModelsADA.solve_dopf_atc_coordinated","text":"solve_dopf_atc_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level = true, alpha::Real=1000)\n\nSolve the distributed OPF problem using ATC algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : print mismatch after each iteration and result summary \nalpha::Real=1.05 : algorithm parameters\nbeta::Real=1.0 : algorithm parameters\n\n\n\n\n\n","category":"function"},{"location":"atc/#PowerModelsADA.atc_methods","page":"ATC","title":"PowerModelsADA.atc_methods","text":"ATC algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"atc/#PowerModelsADA.atc_methods.build_method-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_methods.build_method","text":"build PowerModel object for the ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.initialize_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_methods.initialize_method","text":"initialize the ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.objective_atc-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_methods.objective_atc","text":"ATC algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.solve_method-Tuple{Any, DataType, Any}","page":"ATC","title":"PowerModelsADA.atc_methods.solve_method","text":"solve distributed OPF using ATC algorithm\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ATC","title":"PowerModelsADA.atc_methods.update_method","text":"update the ATC algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods","text":"ATC algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.build_method_coordinator-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.build_method_coordinator","text":"build PowerModel object for the ATC algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.build_method_local","text":"build PowerModel object for ATC algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.initialize_method_coordinator","text":"initialize the ATC algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\", DataType}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.initialize_method_local","text":"initialize the ATC algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.objective_atc_coordinator-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.objective_atc_coordinator","text":"ATC algorithm objective function of the local area\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.objective_atc_local-Tuple{AbstractPowerModel}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.objective_atc_local","text":"ATC algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.solve_method-Tuple{Any, DataType, Any}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.solve_method","text":"solve distributed OPF using ATC algorithm with central coordinator\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.update_method_coordinator","text":"update the ATC algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"atc/#PowerModelsADA.atc_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ATC","title":"PowerModelsADA.atc_coordinated_methods.update_method_local","text":"update the ATC algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#Alternating-Direction-Method-of-Multipliers-(ADMM)","page":"ADMM","title":"Alternating Direction Method of Multipliers (ADMM)","text":"","category":"section"},{"location":"admm/#PowerModelsADA.solve_dopf_admm","page":"ADMM","title":"PowerModelsADA.solve_dopf_admm","text":"solve_dopf_admm(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, print_optimizer_info::Bool=false, alpha::Real=1000)\n\nSolve the distributed OPF problem using ADMM algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\ntol_dual::Float64=1e-4 : dual residual tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"admm/#PowerModelsADA.solve_dopf_admm_coordinated","page":"ADMM","title":"PowerModelsADA.solve_dopf_admm_coordinated","text":"solve_dopf_admm_coordinated(data::Dict{String, <:Any}, model_type::DataType, optimizer; tol::Float64=1e-4, \nmax_iteration::Int64=1000, print_level::Int64=1, alpha::Real=1000)\n\nSolve the distributed OPF problem using ADMM algorithm with central coordinator.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameters\n\n\n\n\n\n","category":"function"},{"location":"admm/#PowerModelsADA.admm_methods","page":"ADMM","title":"PowerModelsADA.admm_methods","text":"ADMM algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"admm/#PowerModelsADA.admm_methods.build_method-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_methods.build_method","text":"build PowerModel object for the ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.initialize_method-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", Type}","page":"ADMM","title":"PowerModelsADA.admm_methods.initialize_method","text":"initialize the ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.objective_admm-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_methods.objective_admm","text":"ADMM algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.solve_method-Tuple{Any, Type, Any}","page":"ADMM","title":"PowerModelsADA.admm_methods.solve_method","text":"solve distributed OPF using ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_methods.update_method-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ADMM","title":"PowerModelsADA.admm_methods.update_method","text":"update the ADMM algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods","text":"ADMM algorithm module containsbuild and update methods\n\n\n\n\n\n","category":"module"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.build_method_coordinator-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.build_method_coordinator","text":"build PowerModel object for the ADMM algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.build_method_local","text":"build PowerModel object for the ADMM algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.initialize_method_coordinator","text":"initializethe ADMM algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s175\"} where var\"#s175\", DataType}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.initialize_method_local","text":"initialize the ADMM algorithm local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.objective_admm_coordinator-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.objective_admm_coordinator","text":"ADMM algorithm objective function of the local area\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.objective_admm_local-Tuple{AbstractPowerModel}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.objective_admm_local","text":"ADMM algorithm objective function of the coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.solve_method-Tuple{Any, DataType, Any}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.solve_method","text":"solve distributed OPF using ADMM algorithm with central coordinator\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s179\"} where var\"#s179\"}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.update_method_coordinator","text":"update the ADMM algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"admm/#PowerModelsADA.admm_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"ADMM","title":"PowerModelsADA.admm_coordinated_methods.update_method_local","text":"update the ADMM algorithm coordinator data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"data_structure/#Data-Structure","page":"Data Structure","title":"Data Structure","text":"","category":"section"},{"location":"data_structure/#Input-Data","page":"Data Structure","title":"Input Data","text":"","category":"section"},{"location":"data_structure/#Case","page":"Data Structure","title":"Case","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"PowerModelsADA uses a dictionary of dictionaries to store the case data and the subproblem data. The case data dictionary is similar to the one in PowerModels with area assignment for each bus. The buses in the data dictionary must contain an area key with more than one distinct area ID. The subproblem data is similar to the case data with additional information. The area data contains the area-specific data and the distributed algorithm parameters.","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To load a data file, we use parse_file function as follow:","category":"page"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"case_path = \"test/data/case14.m\"\ndata = parse_file(case_path)","category":"page"},{"location":"data_structure/#Partitioning","page":"Data Structure","title":"Partitioning","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To check the areas ID in a data dictionary, use get_areas_id(data) to get all areas' IDs in data. If the data dictionary doesn't contain more than one area, we can partition the system manually using assign_area! function. An example of partition file is shown in partition example.","category":"page"},{"location":"data_structure/#PowerModelsADA.assign_area!","page":"Data Structure","title":"PowerModelsADA.assign_area!","text":"assign area to the system data using a dictionary with (bus => area) integers pairs\n\n\n\n\n\nassign area to the system data using a CVS file with buses and area ID\n\n\n\n\n\nassign area to the system data using a vector with (bus => area) pairs\n\n\n\n\n\nassign area to the system data using a matrix with [bus, area] columnsor rows\n\n\n\n\n\n","category":"function"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"Before running the distributed algorithm, PowerModelsADA internally decomposes the original system into subsystems using decompose_system function. the function decouples the tie-lines between two areas by introducing dummy buses and virtual generators at the tie-lines' ends.","category":"page"},{"location":"data_structure/#PowerModelsADA.decompose_system","page":"Data Structure","title":"PowerModelsADA.decompose_system","text":"decompose_system(data::Dict{String, <:Any})\n\ndecompose a system into areas defined by bus area.\n\n\n\n\n\nobtain an area decomposition with area ID\n\n\n\n\n\n","category":"function"},{"location":"data_structure/#Output-Data","page":"Data Structure","title":"Output Data","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"The output of the distributed algorithms is stored in a dictionary. The dictionary's keys are the areas ID, and the dictionary's values are the areas data dictionary with the results stored in solution dictionary.","category":"page"},{"location":"data_structure/#Saving-Iterations-Data","page":"Data Structure","title":"Saving Iterations Data","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To save a specific data during the distributed algorithm (e.g., store the \"shared_variable\" dictionary each iteration), use the option save_data::Vector{String}=[] in the solve function and add the key of the data (e.g., save_data=[\"shared variable\"]). The output of the solve function will contain a dictionary with a key called \"previous_solution\" that contains vectors of the selected stored data ordered by the iteration number.","category":"page"},{"location":"data_structure/#Generation-Cost","page":"Data Structure","title":"Generation Cost","text":"","category":"section"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To calculate the objective function of the central algorithm use calc_dist_gen_cost.","category":"page"},{"location":"data_structure/#PowerModelsADA.calc_dist_gen_cost","page":"Data Structure","title":"PowerModelsADA.calc_dist_gen_cost","text":"calculate distributed solution operation cost\n\n\n\n\n\n","category":"function"},{"location":"data_structure/","page":"Data Structure","title":"Data Structure","text":"To compare the distributed algorithm objective function value with the central OPF, use compare_solution to get the absolute value of the relative error.","category":"page"},{"location":"data_structure/#PowerModelsADA.compare_solution","page":"Data Structure","title":"PowerModelsADA.compare_solution","text":"compare the distributed algorithm solution with PowerModels centralized solution\n\n\n\n\n\n","category":"function"},{"location":"adaptive_admm/#Adaptive-Alternating-Direction-Method-of-Multipliers-(Adaptive-ADMM)","page":"Adaptive ADMM","title":"Adaptive Alternating Direction Method of Multipliers (Adaptive ADMM)","text":"","category":"section"},{"location":"adaptive_admm/#PowerModelsADA.solve_dopf_adaptive_admm","page":"Adaptive ADMM","title":"PowerModelsADA.solve_dopf_adaptive_admm","text":"solve_dopf_adaptive_admm(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, print_optimizer_info::Bool=false, alpha::Real=1000)\n\nSolve the distributed OPF problem using adaptive ADMM algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"adaptive_admm/#PowerModelsADA.solve_dopf_adaptive_admm_coordinated","page":"Adaptive ADMM","title":"PowerModelsADA.solve_dopf_adaptive_admm_coordinated","text":"solve_dopf_adaptive_admm(data::Dict{String, <:Any}, model_type::DataType, optimizer; \nmismatch_method::String=\"norm\", tol::Float64=1e-4, max_iteration::Int64=1000, \nprint_level::Int64=1, print_optimizer_info::Bool=false, alpha::Real=1000)\n\nSolve the distributed OPF problem using adaptive ADMM algorithm.\n\nArguments:\n\ndata::Dict{String, <:Any} : dictionary contains case in PowerModel format\nmodel_type::DataType : power flow formulation (PowerModel type)\noptimizer : optimizer JuMP initiation object\nmismatch_method::String=\"norm\" : mismatch calculation method (norm, max)\ntol::Float64=1e-4 : mismatch tolerance\nmax_iteration::Int64=1000 : maximum number of iteration\nprint_level::Int64=1 : 0 - no print, 1 - print mismatch after each iteration and result summary, 2 - print optimizer output\nalpha::Real=1000 : algorithm parameter\n\n\n\n\n\n","category":"function"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods","text":"adaptive ADMM algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.build_method-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.build_method","text":"build PowerModel object for the adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.calc_dual_residual_adaptive!-Tuple{Dict{String, var\"#s176\"} where var\"#s176\"}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.calc_dual_residual_adaptive!","text":"calc_dual_residual!(data::Dict{String, <:Any}; central::Bool=false)\n\ncalculate the dual redidual as seen by the area. Set central=true if the algorithm uses the optimality condition of a central coordinator.\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.initialize_method-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", DataType}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.initialize_method","text":"initialize the adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.objective_adaptive_admm-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.objective_adaptive_admm","text":"adaptive ADMM algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.solve_method-Tuple{Any, DataType, Any}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.solve_method","text":"solve distributed OPF using adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_methods.update_method-Tuple{Dict{String, var\"#s175\"} where var\"#s175\"}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_methods.update_method","text":"update the adaptive ADMM algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods","text":"adaptive ADMM algorithm module contains build and update methods\n\n\n\n\n\n","category":"module"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.build_method_coordinator-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.build_method_coordinator","text":"build PowerModel object for the ADMM algorithm coordinator\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.build_method_local-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.build_method_local","text":"build PowerModel object for the adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.initialize_method_coordinator-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", DataType}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.initialize_method_coordinator","text":"initialize the adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.initialize_method_local-Tuple{Dict{String, var\"#s177\"} where var\"#s177\", DataType}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.initialize_method_local","text":"initialize the adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.objective_adaptive_admm_coordinator-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.objective_adaptive_admm_coordinator","text":"adaptive ADMM algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.objective_adaptive_admm_local-Tuple{AbstractPowerModel}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.objective_adaptive_admm_local","text":"adaptive ADMM algorithm objective function\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.solve_method-Tuple{Any, DataType, Any}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.solve_method","text":"solve distributed OPF using adaptive ADMM algorithm\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.update_method_coordinator-Tuple{Dict{String, var\"#s177\"} where var\"#s177\"}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.update_method_coordinator","text":"update the adaptive ADMM algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"adaptive_admm/#PowerModelsADA.adaptive_admm_coordinated_methods.update_method_local-Tuple{Dict{String, var\"#s178\"} where var\"#s178\"}","page":"Adaptive ADMM","title":"PowerModelsADA.adaptive_admm_coordinated_methods.update_method_local","text":"update the adaptive ADMM algorithm data after each iteration\n\n\n\n\n\n","category":"method"},{"location":"#PowerModelsADA.jl","page":"Home","title":"PowerModelsADA.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA.jl (Power Models Alternating Distributed Algorithms) provides a framework to solve Optimal Power Flow (OPF) problems using alternating distributed algorithms. The package allows to use different distributed algorithms. PowerModelsADA is built on top of PowerModels.jl and JuMP.jl to model and solve the subproblems.","category":"page"},{"location":"#Distributed-Algorithms","page":"Home","title":"Distributed Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The PowerModelsADA framework is designed to easily incorporate new alternating distributed algorithms. The framework provides means to decompose a test case into multiple areas, model the subproblems associated with each area using PowerModels, solve the supropblems in parallel using multi-threading or multi-processing via Distributed Computing, communicate the shared data between the areas, and calculate the mismatches to decide if the termination criteria are satisfied.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current version of PowerModelsADA implements four distributed algorithms:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternating Direction Method of Multipliers (ADMM)\nAnalytical Target Cascading (ATC)\nAuxiliary Problem Principle (APP)\nAugmented Lagrangian Alternating Direction Inexact Newton (ALADIN)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The specifications of the distributed algorithms are contained in modules within PowerModelsADA and can be used with the algorithms' solve functions. The distributed algorithms variations and solve functions are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithm Module Solve Function\nADMM (fully distributed) admm_methods solve_dopf_admm\nADMM (with a coordinator) admm_coordinated_methods solve_dopf_admm_coordinated\nAdaptive ADMM (fully distributed) adaptive_admm_methods solve_dopf_adaptive_admm\nAdaptive ADMM (with a coordinator) adaptive_admm_coordinated_methods solve_dopf_adaptive_admm_coordinated\nATC (fully distributed) atc_methods solve_dopf_atc\nATC (with a coordinator) atc_coordinated_methods solve_dopf_atc_coordinated\nAPP app_methods solve_dopf_app\nALADIN (with a coordinator) aladin_coordinated_methods solve_dopf_aladin_coordinated","category":"page"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA can be extended to include variations of the existing algorithms or new user-defined algorithms. More details about the formulations and algorithm implementations are shown in Technical Specifications","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerModelsADA can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"PowerModelsADA\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An example demonstrating how to code up and solve the OPF problem with distributed algorithms is found in Quick Start Guide section of the documentation.","category":"page"},{"location":"#Contributions","page":"Home","title":"Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions and enhancements of PowerModelADA are welcomed and encouraged. Please feel free to fork this repository and share your contributions to the main branch with a pull request.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find PowerModelsADA useful for your work, please cite our paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@ARTICLE{alkhraijah2023powermodelsada,\n  author={Alkhraijah, Mohannad and Harris, Rachel and Coffrin, Carleton and Molzahn, Daniel K.},\n  journal={IEEE Transactions on Power Systems}, \n  title={PowerModelsADA: A Framework for Solving Optimal Power Flow using Distributed Algorithms}, \n  year={2023},\n  volume={},\n  number={},\n  pages={1-4},\n  doi={10.1109/TPWRS.2023.3318858}\n}","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is partially supported by the NSF AI Institute for Advances in Optimization (Award #2112533).","category":"page"},{"location":"tutorial/#Tutorial","page":"Using PowerModelsADA","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"PowerModelsADA solves OPF problems using either a pre-defined distributed algorithm or a user-defined algorithm. This page shows examples of solving the OPF problem using the pre-defined algorithms and how to define a new alternating distributed algorithm.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"The distributed algorithm-specific functions are stored in modules. Each module contains at least three main functions: initialize, build, and update functions. Each module also contains a solve function that solves the OPF by passing the case, solver, and power flow model.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"The distributed algorithm module and solve function are:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"Algorithm Module Solve Function\nADMM (fully distributed) admm_methods solve_dopf_admm\nADMM (with a coordinator) admm_coordinated_methods solve_dopf_admm_coordinated\nAdaptive ADMM (fully distributed) adaptive_admm_methods solve_dopf_adaptive_admm\nAdaptive ADMM (with a coordinator) adaptive_admm_coordinated_methods solve_dopf_adaptive_admm_coordinated\nATC (fully distributed) atc_methods solve_dopf_atc\nATC (with a coordinator) atc_coordinated_methods solve_dopf_atc_coordinated\nAPP app_methods solve_dopf_app\nALADIN (with a coordinator) aladin_coordinated_methods solve_dopf_aladin_coordinated","category":"page"},{"location":"tutorial/#Run-Distributed-Algorithm","page":"Using PowerModelsADA","title":"Run Distributed Algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To solve the OPF problem, we need first to import the PowerModelsADA package and an optimization solver. In this case we use the NLP solver Ipopt. You can install the solver using using Pkg; Pkg.add(\"Ipopt\"). Then run the following code:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"## Import package\nusing PowerModelsADA\nusing Ipopt ","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"Next, we need to upload a test case. We will use IEEE 14-bus system in /test/data/ folder in MATPOWER format. The file can be loaded using parse_file from PowerModels package. The test system needs to be divided into multiple distinct areas. This can be checked by looking into data[\"bus\"][bus_id][\"area\"].","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"## Read case with partition file and return dictionary of the partitioned case\ncase_path = \"test/data/case14.m\"\npartition_file_path = \"test/data/case14_2areas.csv\"\ndata = parse_file(case_path)\nassign_area!(data, partition_file_path)","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"Now, the case study is loaded and ready to be used to solve the OPF problem using distributed algorithms. We first need to define parameters, load the solver, and select a power flow formulation model_type as follows:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"\n## Settings and optimizer initiation\nmax_iteration = 1000\ntol = 1e-4\nalpha = 1000\noptimizer = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\"=>0)","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"PowerModelsADA supports the following power flow models:","category":"page"},{"location":"tutorial/#Exact-power-flow","page":"Using PowerModelsADA","title":"Exact power flow","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"model_type = ACPPowerModel # AC power flow model with polar bus voltage variables.\nmodel_type = ACRPowerModel # AC power flow model with rectangular bus voltage variables.","category":"page"},{"location":"tutorial/#Approximations","page":"Using PowerModelsADA","title":"Approximations","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"model_type = DCPPowerModel # Linearized 'DC' power flow model.\nmodel_type = LPACCPowerModel # LP AC power flow approximation.","category":"page"},{"location":"tutorial/#Convex-relaxations","page":"Using PowerModelsADA","title":"Convex relaxations","text":"","category":"section"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"model_type = SOCWRPowerModel # Second-order cone relaxation of bus injection model of AC power flow.\nmodel_type = QCRMPowerModel # Quadratic-Convex relaxation of the AC power flow.\nmodel_type = SDPWRMPowerModel # Semidefinite relaxation of AC power flow.\nmodel_type = SparseSDPWRMPowerModel # Sparsity-exploiting semidefinite relaxation of AC power flow.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To solve the OPF problem using ADMM algorithm using the solve function, we use the following:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"data_area = solve_dopf_admm(data, model_type, optimizer, tol=tol, max_iteration=max_iteration, alpha=alpha)\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To use multiprocessing features, we need to use the Distributed library, add processors, and upload the PowerModelsADA and the solver packages to the processors. For the best performance, the number of processors should be equal to the number of areas. The code becomes as follows:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"using Distributed \nnum_area = 4 # change the number to be equal to number of areas\naddprocs(num_area, exeflags=\"--project\")\n@everywhere using PowerModelsADA\n@everywhere using Ipopt\ndata_area = solve_dopf_admm(data, model_type, optimizer, tol=tol, max_iteration=max_iteration, alpha=alpha, multiprocessors=true)","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"To compare the distributed algorithm objective function value with the central OPF, use compare_solution to get the absolute value of the relative error.","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"optimality_gap = compare_solution(data, data_area, model_type, optimizer)","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"PowerModelsADA also provides the flexibility for more granular control of the distributed algorithm. We can use the following code to initialize the distributed algorithm (we use ADMM in this example).","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"\n## define parameters and power flow model\nmax_iteration = 1000\ntol = 1e-4\nalpha = 1000\nmodel_type = DCPPowerModel\n\n## obtain areas idx\nareas_id = get_areas_id(data)\n\n## decompose the system into subsystems\ndata_area = decompose_system(data)\n\n## initialize parameters using the algorithm-specific initialize function\nfor i in areas_id\n    admm_methods.initialize_method(data_area[i], model_type; tol=tol, max_iteration=max_iteration, alpha = alpha)\nend\n","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"We then start the iterative process of the distributed algorithm using while loop with a pre-define termination criteria as follows:","category":"page"},{"location":"tutorial/","page":"Using PowerModelsADA","title":"Using PowerModelsADA","text":"## initialize global counters\niteration = 0\nflag_convergence = false\n\n## start iteration\nwhile iteration < max_iteration && flag_convergence == false\n\n    ## solve local problem and update solution\n    for i in areas_id\n        result = solve_pmada_model(data_area[i], model_type, optimizer, admm_methods.build_method, solution_processors=admm_methods.post_processors)\n        update_data!(data_area[i], result[\"solution\"])\n    end\n\n    ## share solution with neighbors\n    for i in areas_id # sender subsystem\n        for j in data_area[i][\"neighbors\"] # receiver subsystem\n            shared_data = prepare_shared_data(data_area[i], j)\n            receive_shared_data!(data_area[j], deepcopy(shared_data), i)\n        end\n    end\n\n    # calculate mismatches and update convergence flags\n    for i in areas_id\n        dopf_method.update_method(data_area[i])\n    end\n\n    ## check global convergence and update iteration counters\n    flag_convergence = update_global_flag_convergence(data_area)\n    iteration += 1\nend\n","category":"page"}]
}

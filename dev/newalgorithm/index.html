<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User-defined Algorithm · PowerModelsADA.jl</title><meta name="title" content="User-defined Algorithm · PowerModelsADA.jl"/><meta property="og:title" content="User-defined Algorithm · PowerModelsADA.jl"/><meta property="twitter:title" content="User-defined Algorithm · PowerModelsADA.jl"/><meta name="description" content="Documentation for PowerModelsADA.jl."/><meta property="og:description" content="Documentation for PowerModelsADA.jl."/><meta property="twitter:description" content="Documentation for PowerModelsADA.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerModelsADA.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../quickguide/">Quick Start Guide</a></li><li><a class="tocitem" href="../data_structure/">Data Structure</a></li><li><a class="tocitem" href="../specification/">Technical Specifications</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Distributed Algorithms</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../admm/">ADMM</a></li><li><a class="tocitem" href="../atc/">ATC</a></li><li><a class="tocitem" href="../app/">APP</a></li><li><a class="tocitem" href="../aladin/">ALADIN</a></li><li><a class="tocitem" href="../adaptive_admm/">Adaptive ADMM</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorial/">Using PowerModelsADA</a></li><li class="is-active"><a class="tocitem" href>User-defined Algorithm</a></li></ul></li><li><a class="tocitem" href="../library/">Library</a></li><li><a class="tocitem" href="../comparison/">Comparison Results</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>User-defined Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User-defined Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mkhraijah/PowerModelsADA.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mkhraijah/PowerModelsADA.jl/blob/main/docs/src/newalgorithm.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Defined-Algorithm"><a class="docs-heading-anchor" href="#User-Defined-Algorithm">User-Defined Algorithm</a><a id="User-Defined-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#User-Defined-Algorithm" title="Permalink"></a></h1><p>To define a new algorithm, we need to define a module for the new algorithm that contains the main solve function in addition to three algorithm-specific functions. The three algorithm-specific are: initialize, build, and update. You can follow the example in the <a href="https://github.com/mkhraijah/PowerModelsADA.jl/blob/main/example/template.jl">template file</a>.</p><p>The module of <code>xx</code> algorithm should be defined and exported as <code>xx_methods</code> as follows:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
template for xx distributed algorithm
&quot;&quot;&quot;
module xx_methods
using ..PowerModelsADA

### functions ###

end
# export the algorithm methods module and call method
export xx_methods, solve_dopf_xx</code></pre><p>The solve function is the main method to use the <code>xx</code> algorithm. The function takes the data, power flow formulation (<code>model_type</code>), JuMP solver object, and algorithm&#39;s parameters as required. The solve function should use the pre-defined algorithm flow as follows:</p><pre><code class="language-julia hljs">&quot;solve distributed OPF using xx algorithm&quot;
function solve_method(data, model_type::DataType, optimizer; 
    mismatch_method::String=&quot;norm&quot;, tol::Float64=1e-4, max_iteration::Int64=1000, 
    print_level::Int64=1, parameters...)

    solve_dopf(data, model_type, optimizer, xx_methods; 
    mismatch_method=mismatch_method, tol=tol, max_iteration=max_iteration, 
    print_level=print_level, parameters...)
end</code></pre><p>The first algorithm-specific function is the initialize function. The function takes the area data file and adds to it the required parameters, counters, and shared variables. There are multiple built-in functions in <code>PowerModelsADA</code> that can be used to define the shared and received variables, as well as the dual variables. Note that the initialization function should include the <code>initialize_dopf!</code> to define the counters and convergence flags. We use <code>kwargs</code> with the <code>...</code> to combine the algorithm&#39;s parameters and pass them to the <code>initialize_method</code>.</p><pre><code class="language-julia hljs">&quot;initialize the xx algorithm&quot;
function initialize_method(data::Dict{String, &lt;:Any}, model_type::Type; kwargs...)

    # initiate primal and dual shared variables
    data[&quot;shared_variable&quot;] = Dict(to_area=&gt; variable_name=&gt; variable_index=&gt; value)
    data[&quot;received_variable&quot;] = Dict(from_area=&gt; variable_name=&gt;variable_index=&gt; value)

    # distributed algorithm settings
    initialize_dopf!(data, model_type; kwargs...)

    # xx parameters
    data[&quot;parameter&quot;] = Dict(&quot;alpha&quot;=&gt; get(kwargs, :alpha, 1000))

end</code></pre><p>The second function is the build function, which builds the <code>PowerModels</code> object of the subproblem. The subproblems typically have the same variables and constraints as the central OPF problem and differ in the objective functions. To build a subproblem with the same variables and constraints as the central OPF problem with a specific objective function, we need to define the objective function using the template shown below. The objective function definition takes the <code>PowerModels</code> object and returns a <code>JuMP</code> expression. You can use the internal helper function <code>_var</code> to obtain the <code>JuMP</code> model variables&#39; object defined in the <code>PowerModels</code> object.</p><pre><code class="language-julia hljs">&quot;build PowerModel using xx algorithm&quot;
function build_method(pm::AbstractPowerModel)

    # define variables
    variable_opf(pm)

    # define constraints
    constraint_opf(pm)
  
    # define objective function
    objective_min_fuel_and_consensus!(pm, objective_function)
end

&quot;set the xx algorithm objective&quot;
function objective_function(pm::AbstractPowerModel)

    # to get the JuMP object of the active power of generator 1 use:
    pg1 = _var(pm, :pg, 1)

    ###
    objective = pg1
    ###
    return objective
end</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModelsADA._var" href="#PowerModelsADA._var"><code>PowerModelsADA._var</code></a> — <span class="docstring-category">Function</span></header><section><div><p>return JuMP variable object from PowerModel object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mkhraijah/PowerModelsADA.jl/blob/b23a78422361e045a33d85e3524a3926e9af29b3/src/core/variables.jl#L128">source</a></section></article><p>The last function is to update the area dictionary after communicating the shared variables results with other areas.</p><pre><code class="language-julia hljs">&quot;update the xx algorithm before each iteration&quot;
function update_method(data::Dict{String, &lt;:Any})

    ### update subproblem parameters for the next iteration
    ###

    ### you can use predefined function to calculate the mismatches, check convergence, save progress etc. 

    calc_mismatch!(data, central=true)
    update_flag_convergence!(data)
    save_solution!(data)
    update_iteration!(data)
end
</code></pre><p>The final step is defining the post-processing functions and global keys. The post-processing functions perform tasks to the <code>PowerModels</code> object after solving the subproblem. <code>PowerModelsADA</code> comes with two post-processing functions. The first function updates the solution dictionary, and the second function updates the shared variables dictionary. The global keys are the keys that are used in the data area dictionary (related to the <code>xx</code> algorithm) and should be explicitly given by extending the existing <code>_pmada_global_keys</code> set of strings.</p><pre><code class="language-julia hljs">post_processors = [update_solution!, update_shared_variable!]

push!(_pmada_global_keys, &quot;shared_variable&quot;, &quot;received_variable&quot;, &quot;dual_variable&quot;)</code></pre><p>This is a general way to define a distributed algorithm that is fully distributed with the same main algorithm flow as the pre-defined algorithms. For other algorithm flows, the solve function needs to be defined fully instead of using the pre-define function <code>solve_dopf</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Using PowerModelsADA</a><a class="docs-footer-nextpage" href="../library/">Library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Friday 13 October 2023 22:25">Friday 13 October 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
